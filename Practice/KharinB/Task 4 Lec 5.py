def fun(arr, x):
    y = []
    for i in arr:
        if x in i:
            for j in range(len(i)):
                if i[j] == x:
                    y.append(j)  #
    if y != []:
        y = list(set(y))

        # Чтобы не делать строчку 9, можно в строчке 6, сделать проверку:
        # if i[j] == x and j not in y:
        # Но если матрица будет 300х300, то в худшем случае, в конце, он будет делать 300 проверок по 300 элементов, а тут вроде один раз удалил повторяющиеся и всё.
        # Отсюда вопрос: что итератору сделать быстрее и проще? Просто я не совсем понимаю что происходит под капотом, когда итератор преобразует список в множество.

        y.sort(
            reverse=True)  # переворачиваю список, чтобы удалять столбцы в обратном порядке, иначе нумерация сбивается.
        for c in y:
            for g in arr:
                g.pop(c)
    return None


# Я решил проблему, но как мне кажется - я перемудрил... Пробовал метод с прокастинацией, не особо помогло, идеи всё равно не идут в голову...)))

matrix = input("Введите матрицу: ") or [["a", 3, 6], [3, 7, 5], [0, 5, 3]]
x = input("Введите символ: ") or "3"
if x.isdecimal():
    x = int(x)
a = fun(matrix, x)
print(matrix)
